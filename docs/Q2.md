# 50 Interview Questions & Answers - Full Stack Blog Admin System

This document contains 50 comprehensive interview questions and answers covering the entire full-stack blog admin system, including backend microservices, frontend, database, caching, security, and DevOps aspects.

---

## Table of Contents

1. [Architecture & Design](#architecture--design)
2. [Backend - Spring Boot & Java](#backend---spring-boot--java)
3. [Frontend - React & TypeScript](#frontend---react--typescript)
4. [Security & Authentication](#security--authentication)
5. [Database & Caching](#database--caching)
6. [DevOps & Docker](#devops--docker)

---

## Architecture & Design

### Q1: What is the overall architecture of this full-stack application?

**Answer:** This is a microservices-based architecture consisting of:
- **Auth Service** (Spring Boot on port 8081) - Handles user authentication, JWT token generation, and validation
- **Blog Service** (Spring Boot on port 8082) - Manages article CRUD operations
- **Frontend** (React + Nginx on port 8080) - Single Page Application that acts as the user interface and reverse proxy
- **Shared PostgreSQL Database** - Stores users and articles
- **Shared Redis (auth-cache)** - Manages JWT blacklist, refresh tokens, and sessions
- **Local Redis (blog-cache)** - Caches article data for performance

The Nginx reverse proxy routes `/api/auth/*` to auth-service and `/api/articles/*` to blog-service, ensuring the frontend never directly addresses the backend services.

---

### Q2: Why was a microservices architecture chosen over a monolithic approach?

**Answer:** 
- **Separation of Concerns** - Authentication logic is isolated from business logic, making each service easier to understand and maintain
- **Scalability** - Each service can be scaled independently based on demand (auth-service during login peaks, blog-service for article operations)
- **Technology Flexibility** - Different services could use different technologies if needed in the future
- **Development Parallelization** - Multiple teams can work on different services simultaneously
- **Fault Isolation** - If one service fails, others continue operating (partial availability)
- **Deployment Independence** - Services can be updated and deployed without affecting others

---

### Q3: What are the security implications of storing the JWT in an HttpOnly cookie?

**Answer:**
- **XSS Protection** - HttpOnly cookies cannot be accessed via JavaScript, protecting against Cross-Site Scripting attacks that might steal tokens from localStorage
- **CSRF Mitigation** - The system uses XSRF-TOKEN headers for state-changing requests, protecting against Cross-Site Request Forgery
- **Automatic Transmission** - The browser automatically sends HttpOnly cookies with API requests, eliminating the need for manual header management
- **Same-Site Restriction** - Can be configured with `SameSite=Strict` to prevent cross-site cookie sending
- **Tradeoff** - Unlike localStorage, HttpOnly cookies are vulnerable to CSRF attacks, which is why CSRF tokens are implemented
- The system balances security by using both HttpOnly cookies (for XSS protection) and CSRF tokens (for CSRF protection)

---

### Q4: Explain the request flow from the React frontend to the Blog Service.

**Answer:**
1. User submits a form in React (e.g., create article)
2. React calls `api.post('/articles', data)` using Axios
3. The Axios interceptor adds the XSRF token from the cookie to the request header
4. The request is sent to `http://localhost:8080/api/articles` (Nginx)
5. Nginx reverse proxy routes it to `http://blog-service:8082/articles`
6. Blog Service's `JwtAuthFilter` extracts JWT from the HttpOnly cookie
7. `JwtAuthFilter` validates the JWT and sets up Spring Security context
8. `TokenValidationFilter` checks if the JWT's JTI is blacklisted in Redis
9. `ArticleController` receives the request and calls `ArticleService`
10. `ArticleService` uses `@PreAuthorize` to check permissions (ADMIN or owner)
11. Response is returned to Nginx, which forwards it back to React
12. React updates the UI with the result

---

### Q5: What is the purpose of the `TokenValidationFilter` in the blog-service?

**Answer:**
The `TokenValidationFilter` performs a secondary security check to ensure that logged-out tokens are rejected even if their JWT signature is still valid. Specifically:
- It intercepts all incoming requests to the blog-service
- Extracts the JWT's JTI (JWT ID) claim - a unique identifier for that token
- Checks if the JTI exists in the Redis "blacklist" (stored in auth-cache)
- If the JTI is blacklisted, the request is rejected with 403 Forbidden
- This prevents revoked tokens from being used across microservices
- It implements "fail-open" behavior - if Redis is unavailable, it allows requests to proceed (logging a warning) to ensure service availability
This is a critical part of the JTI-based token revocation pattern used throughout the system.

---

## Backend - Spring Boot & Java

### Q6: How does the JWT token generation work in the auth-service?

**Answer:**
The `JwtUtil` component generates JWT tokens with the following process:
1. **Claim Creation** - Creates a claims map including:
   - `sub` (subject) - the user's email
   - `jti` - a unique UUID for this token instance
   - `role` - the user's role (USER or ADMIN)
   - `iat` (issued at) - current timestamp
   - `exp` (expiration) - current time + JWT expiration value (10 hours)
2. **Secret Key** - Loads the shared JWT secret from environment variables and decodes it from Base64
3. **Token Generation** - Uses JJWT library to create a signed JWT token with HS256 algorithm
4. **Storage** - The JTI is stored in Redis for later blacklist checking
5. **Return** - The encoded JWT is returned as a string to the client

The token is signed with the same secret used by blog-service, allowing both services to independently verify token signatures.

---

### Q7: What is the purpose of the JTI (JWT ID) claim, and how does it work?

**Answer:**
The JTI is a unique UUID assigned to each JWT token for the purpose of token revocation:
- **Unique Identifier** - Every JWT generated has a unique JTI, making it individually identifiable
- **Logout Handling** - When a user logs out, the JTI is added to a Redis "blacklist" with a TTL
- **Distributed Validation** - Any service can check if a JTI is blacklisted without re-validating the token's signature
- **Memory Efficiency** - Storing only 36-byte JTIs (vs. 500+ byte full tokens) saves Redis memory
- **Security** - Prevents revoked tokens from being used, even if the JWT signature is technically valid
- **Cross-Service Revocation** - The JTI blacklist is stored in shared auth-cache, so logout on auth-service immediately revokes tokens on blog-service

Example: When a user logs out, the token's JTI is added to Redis with key `blacklist_jti:{jti}` and a TTL equal to the token's remaining lifetime.

---

### Q8: How does password validation work in the auth-service?

**Answer:**
The `PasswordValidator` component validates passwords according to security best practices:
1. **Minimum Length** - Requires at least 8 characters
2. **Maximum Length** - Limits to 72 characters (BCrypt limitation)
3. **Complexity Requirements**:
   - At least one uppercase letter (A-Z)
   - At least one lowercase letter (a-z)
   - At least one digit (0-9)
   - At least one special character (!@#$%^&*)
4. **No Common Patterns** - Rejects obvious patterns like "Password123!"
5. **BCrypt Hashing** - Passwords are hashed using BCrypt before storage in the database

This approach ensures strong passwords that resist brute-force attacks. BCrypt is chosen because:
- It uses automatic salt generation
- It has built-in iteration count, making brute-force attacks exponentially slower
- It's widely supported and security-tested

---

### Q9: What is the role of the `RateLimitFilter` in the auth-service?

**Answer:**
The `RateLimitFilter` protects the login endpoint from brute-force attacks:
1. **Interception** - Intercepts all `POST /auth/login` requests
2. **Client Identification** - Identifies the client by IP address
3. **Redis Counter** - Checks a Redis counter with key `ratelimit:login:{ip}`
4. **Limit Check** - Compares the counter against the configured limit (default 5 attempts)
5. **Window Management** - Uses a time window (default 60 seconds) to reset the counter
6. **Response** - If limit exceeded, returns HTTP 429 (Too Many Requests)
7. **Increment** - Increments the counter with automatic TTL expiration

Configuration is stored in `application.properties`:
- `rate.limit.login=5` - Maximum 5 attempts
- `rate.limit.login.window=60` - Per 60-second window

This prevents attackers from performing rapid-fire login attempts to guess passwords.

---

### Q10: How does the blog-service enforce authorization for article operations?

**Answer:**
Authorization in blog-service uses Spring's `@PreAuthorize` annotation with spEL (Spring Expression Language):

**For viewing articles:**
```java
@PreAuthorize("isAuthenticated()")
public Page<ArticleSummaryDto> getAllArticles(...)
```
- Only authenticated users can list articles
- Admins see all articles; regular users see only their own (checked in service logic)

**For getting a single article:**
```java
@PreAuthorize("hasRole('ADMIN') or @articleSecurity.isOwner(authentication, #id)")
public ArticleDto getArticle(Long id)
```
- Admins can access any article
- Regular users can only access their own articles
- `@articleSecurity.isOwner()` checks article ownership in the `ArticleSecurity` component

**For creating articles:**
```java
@PreAuthorize("isAuthenticated()")
public ArticleDto createArticle(ArticleDto dto)
```
- Any authenticated user can create articles
- Author is set to the current user automatically

**For updating/deleting articles:**
```java
@PreAuthorize("hasRole('ADMIN') or @articleSecurity.isOwner(authentication, #id)")
public ArticleDto updateArticle(Long id, ArticleDto dto)
```
- Same rule as viewing: admins have full access, users can only modify their own

If authorization fails, Spring Security throws an `AccessDeniedException` which the `GlobalExceptionHandler` converts to a 403 Forbidden response.

---

### Q11: What is the `ArticleSecurity` component, and how does it work?

**Answer:**
`ArticleSecurity` is a Spring component that provides custom authorization logic for article ownership:

```java
@Component("articleSecurity")
public class ArticleSecurity {
    @Autowired
    private ArticleRepository articleRepository;
    @Autowired
    private UserRepository userRepository;

    public boolean isOwner(Authentication authentication, Long articleId) {
        String userEmail = authentication.getName();
        Optional<User> userOptional = userRepository.findByEmail(userEmail);
        if (userOptional.isEmpty()) return false;
        
        User currentUser = userOptional.get();
        return articleRepository.findById(articleId)
            .map(article -> article.getAuthor().getId().equals(currentUser.getId()))
            .orElse(false);
    }
}
```

**How it works:**
1. Called from `@PreAuthorize("@articleSecurity.isOwner(authentication, #id)")`
2. Extracts the authenticated user's email from the Authentication object
3. Looks up the user in the database
4. Retrieves the article by ID
5. Compares the article's author ID with the current user's ID
6. Returns true if they match, false otherwise

This allows fine-grained authorization beyond role-based checks, enabling users to modify only their own articles while admins can modify any article.

---

### Q12: How does the service layer handle caching for articles?

**Answer:**
The blog-service uses Spring's `@Cacheable` annotation for performance optimization:

```java
@Cacheable(value = "articles", key = "#id")
public ArticleDto getArticle(Long id)
```

**Cache Configuration:**
- Cache name: "articles"
- Cache key: Article ID
- Storage: Redis (configured in `RedisConfig`)

**Cache Invalidation:**
```java
@CacheEvict(value = "articles", key = "#id")
public ArticleDto updateArticle(Long id, ArticleDto dto)

@CacheEvict(value = "articles", key = "#id")
public void deleteArticle(Long id)
```

**Benefits:**
- **Performance** - Subsequent requests for the same article hit Redis instead of the database
- **Reduced Load** - Database traffic decreases for frequently accessed articles
- **TTL** - Cache entries automatically expire after a configured period

**Tradeoffs:**
- **Stale Data** - There's a window where cached data might not reflect recent updates
- **Consistency** - Manual cache eviction is required when articles are updated/deleted
- **Memory** - Redis memory usage increases with cache size

**Best Practice:** The service evicts cache entries immediately upon update/delete, ensuring consistency while leveraging cache for read-heavy workloads.

---

### Q13: What retry logic is implemented in the ArticleService, and why?

**Answer:**
The `ArticleService` uses Spring's `@Retryable` annotation to handle transient database errors:

```java
@Retryable(
    retryFor = {
        SQLException.class,
        org.springframework.dao.TransientDataAccessException.class,
        org.springframework.dao.CannotAcquireLockException.class,
        org.springframework.dao.ConcurrencyFailureException.class,
        java.net.SocketTimeoutException.class,
        org.springframework.dao.QueryTimeoutException.class
    },
    maxAttempts = 3,
    backoff = @Backoff(delay = 100, multiplier = 2)
)
public Page<ArticleSummaryDto> getAllArticles(...)
```

**Retry Strategy:**
- **Maximum Attempts** - Retries up to 3 times (original + 2 retries)
- **Initial Delay** - Waits 100ms before the first retry
- **Exponential Backoff** - Multiplies delay by 2 for each retry (100ms, 200ms)
- **Total Time** - Up to ~300ms of wait time

**Handled Errors:**
- `SQLException` - General database errors
- `TransientDataAccessException` - Temporary DB connectivity issues
- `CannotAcquireLockException` - Lock timeouts on concurrent updates
- `ConcurrencyFailureException` - Optimistic locking failures
- `SocketTimeoutException` - Network timeouts
- `QueryTimeoutException` - Query execution timeouts

**Why This Works:**
- Most transient errors are temporary (network hiccup, momentary lock contention)
- Retrying with backoff allows the system to recover from brief outages
- Prevents unnecessary failures from short-lived issues
- Does NOT retry non-transient errors like constraint violations

---

### Q14: How is the User entity shared between auth-service and blog-service?

**Answer:**
The User entity is NOT directly shared. Instead, both services have their own `User` entity classes that mirror the database schema:

**Why this architecture:**
- **Database-Driven Design** - The shared PostgreSQL database is the single source of truth
- **Service Independence** - Each service has its own JPA entity mapping
- **Loose Coupling** - Services don't import each other's entity classes
- **Consistency** - The database schema ensures consistency across services

**User Information Flow:**
1. Auth-service creates/updates users in the database
2. Blog-service reads user information when needed (e.g., checking article ownership)
3. Both services use JPA to interact with the `users` table

**Example:**
```java
// auth-service User entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String email;
    private String password; // hashed
    @Enumerated(EnumType.STRING)
    private Role role;
}

// blog-service User entity (mirrors auth-service)
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String email;
    @Enumerated(EnumType.STRING)
    private Role role;
    // Note: No password field - not needed in blog-service
}
```

This pattern ensures both services work with consistent user data while maintaining independence.

---

### Q15: How does the admin account initialization work?

**Answer:**
The `AdminInitializer` component creates a default admin account on first application startup:

```java
@Component
@RequiredArgsConstructor
public class AdminInitializer {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    @Value("${admin.email:admin@example.com}")
    private String adminEmail;
    
    @Value("${admin.password:password123}")
    private String adminPassword;
    
    @PostConstruct
    public void init() {
        if (userRepository.findByEmail(adminEmail).isEmpty()) {
            User admin = new User();
            admin.setEmail(adminEmail);
            admin.setPassword(passwordEncoder.encode(adminPassword));
            admin.setRole(Role.ADMIN);
            userRepository.save(admin);
        }
    }
}
```

**Process:**
1. **@PostConstruct** - Runs automatically after bean initialization
2. **Check Existence** - Queries the database for an admin user
3. **Create if Missing** - If no admin exists, creates one with default credentials
4. **Environment Override** - Admin email/password can be overridden via environment variables:
   - `ADMIN_EMAIL` - Admin email address
   - `ADMIN_PASSWORD` - Admin initial password
5. **Password Hashing** - Uses BCrypt to hash the password before storage
6. **Role Assignment** - Sets the role to ADMIN

**Security Considerations:**
- Should be changed immediately after first login
- Default credentials should never be used in production
- Should be provided through secure secret management (AWS Secrets, Vault)
- The initialization only happens once (checked via database query)

---

## Frontend - React & TypeScript

### Q16: How does the React AuthContext manage authentication state?

**Answer:**
The `AuthContext` is a React Context that provides global authentication state management:

```typescript
interface AuthContextType {
    isAuthenticated: boolean;
    isLoading: boolean;
    login: () => void;
    logout: () => void;
}

export const AuthProvider = ({ children }) => {
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        const checkAuth = async () => {
            try {
                await api.get('/auth/me');
                setIsAuthenticated(true);
            } catch {
                setIsAuthenticated(false);
            } finally {
                setIsLoading(false);
            }
        };
        checkAuth();
    }, []);
    // ...
};
```

**Key Features:**
1. **Session Check on Mount** - On app startup, calls `/auth/me` to validate existing session
2. **Global State** - All components can access `isAuthenticated` and `isLoading` via `useAuth()` hook
3. **Loading State** - Prevents premature rendering while checking authentication
4. **Token Storage** - JWT is stored as HttpOnly cookie (not in Context state)
5. **Login Function** - Sets `isAuthenticated = true` after successful login
6. **Logout Function** - Calls `/auth/logout` API then sets `isAuthenticated = false`

**Usage in Components:**
```typescript
const { isAuthenticated, logout } = useAuth();

if (!isAuthenticated) {
    return <Navigate to="/login" />;
}
```

**Security Benefits:**
- HTTP-only cookie prevents JavaScript access (XSS protection)
- Context only stores boolean state, not sensitive data
- Session validation on every app start

---

### Q17: What is the PrivateRoute component, and how does it work?

**Answer:**
The `PrivateRoute` component protects routes that require authentication:

```typescript
const PrivateRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { isAuthenticated, isLoading } = useAuth();

    if (isLoading) {
        return <div>Loading...</div>;
    }

    if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
    }

    return <>{children}</>;
};

// Usage in App.tsx
<Routes>
    <Route path="/login" element={<Login />} />
    <Route
        path="/articles"
        element={
            <PrivateRoute>
                <ArticleList />
            </PrivateRoute>
        }
    />
</Routes>
```

**How it Works:**
1. **Loading Check** - While authentication is being verified, shows loading state
2. **Auth Check** - Checks if `isAuthenticated` is true
3. **Redirect** - If not authenticated, redirects to `/login` with `replace: true`
4. **Render** - If authenticated, renders the protected component

**Why `replace: true`:**
- Replaces the history entry instead of adding to it
- Prevents users from navigating back to protected pages after logout
- Cleaner user experience

**Alternative Approach - Route Guards:**
```typescript
<Route path="/articles" element={<ArticleList />} />
// With a layout wrapper:
<PrivateRoute>
    <Outlet /> {/* renders child routes */}
</PrivateRoute>
```

---

### Q18: How does the Axios instance handle authentication?

**Answer:**
The Axios instance is configured with several security features:

```typescript
const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json',
    },
    // Enable HttpOnly cookie transmission
    withCredentials: true,
    // CSRF token handling
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
});
```

**Key Configuration:**
1. **baseURL** - All requests prepend this URL (e.g., `/auth/login` becomes `http://localhost:8080/api/auth/login`)
2. **withCredentials** - Enables automatic HttpOnly cookie transmission with every request
3. **xsrfCookieName** - Tells Axios to read CSRF token from `XSRF-TOKEN` cookie
4. **xsrfHeaderName** - Tells Axios to send CSRF token in `X-XSRF-TOKEN` header

**Request Interceptor:**
```typescript
api.interceptors.request.use((config) => {
    const csrfToken = getCsrfToken();
    if (csrfToken && ['post', 'put', 'delete'].includes(config.method)) {
        config.headers['X-XSRF-TOKEN'] = csrfToken;
    }
    return config;
});
```

**Response Interceptor:**
```typescript
api.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);
```

**Authentication Flow:**
1. Browser includes HttpOnly JWT cookie automatically
2. Request interceptor adds CSRF token for state-changing operations
3. Backend validates JWT from cookie
4. Backend validates CSRF token from header
5. If 401, response interceptor redirects to login
6. Response is returned to component

---

### Q19: What is the purpose of the ErrorBoundary component?

**Answer:**
The `ErrorBoundary` is a React component that catches JavaScript errors in child components and displays a fallback UI:

```typescript
class ErrorBoundary extends React.Component<Props, State> {
    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Error caught:', error, errorInfo);
        this.setState({ hasError: true });
    }

    render() {
        if (this.state.hasError) {
            return <div>Something went wrong. Please refresh the page.</div>;
        }
        return this.props.children;
    }
}

// Usage in App.tsx
<ErrorBoundary>
    <AuthProvider>
        <Routes>
            {/* routes */}
        </Routes>
    </AuthProvider>
</ErrorBoundary>
```

**What it Catches:**
- Render method errors
- Constructor errors
- Lifecycle method errors
- Errors in child components

**What it Doesn't Catch:**
- Event handler errors (use try-catch or .catch())
- Async errors (use try-catch in useEffect)
- Server-side rendering errors
- Errors in the ErrorBoundary itself

**Benefits:**
- Prevents entire app crash from a single component error
- Provides graceful degradation
- Logs errors for debugging
- Improves user experience

---

### Q20: How does the ArticleForm component handle form state and validation?

**Answer:**
The `ArticleForm` uses React Hook Form for efficient form management:

```typescript
interface ArticleFormData {
    title: string;
    content: string;
    tags: string;
    publishStatus: 'draft' | 'published';
}

const ArticleForm = () => {
    const { register, handleSubmit, setValue, formState: { errors } } = useForm<ArticleFormData>({
        defaultValues: {
            publishStatus: 'draft'
        }
    });

    // Client-side validation
    <input
        {...register('title', {
            required: 'Title is required',
            maxLength: { value: 200, message: "Max 200 chars" }
        })}
    />
    {errors.title && <span>{errors.title.message}</span>}
};
```

**Features:**

1. **Minimal Re-renders** - Only subscribes to field changes it needs
2. **Client-side Validation** - Validates before submission (better UX)
3. **Server-side Validation** - Backend also validates (security)
4. **Error Display** - Shows validation messages inline

**Form Submission:**
```typescript
const onSubmit = async (data: ArticleFormData) => {
    try {
        if (isEditMode) {
            await api.put(`/articles/${id}`, data);
        } else {
            await api.post('/articles', data);
        }
        navigate('/articles');
    } catch (error) {
        setError("Failed to save article");
    }
};

<form onSubmit={handleSubmit(onSubmit)}>
```

**Edit Mode Loading:**
```typescript
useEffect(() => {
    if (isEditMode) {
        api.get(`/articles/${id}`).then(response => {
            const data = response.data;
            setValue('title', data.title);
            setValue('publishStatus', data.publishStatus.toLowerCase());
        });
    }
}, [id, isEditMode, setValue]);
```

**Key Benefits:**
- **Performance** - Minimal re-renders compared to useState
- **Developer Experience** - Less boilerplate code
- **User Experience** - Real-time validation feedback
- **Type Safety** - Full TypeScript support

---

## Security & Authentication

### Q21: Explain the complete logout process and why JTI blacklisting is important.

**Answer:**
The logout process involves multiple steps to ensure tokens cannot be reused:

**Logout API Call (Frontend):**
```typescript
const logout = async () => {
    await api.post('/auth/logout'); // calls auth-service
    setIsAuthenticated(false);
};
```

**Backend Logout (auth-service):**
```java
@PostMapping("/auth/logout")
public ResponseEntity<String> logout(HttpServletRequest request) {
    String token = extractToken(request);
    if (token != null) {
        String jti = jwtUtil.extractJti(token);
        long remainingTime = jwtUtil.getExpirationTime(token);
        
        // Add JTI to blacklist with TTL = remaining token lifetime
        tokenCacheService.blacklistToken(jti, remainingTime);
        
        // Invalidate session
        tokenCacheService.invalidateSession(token);
        
        // Clear token cookie
        response.addCookie(createEmptyCookie());
    }
    return ResponseEntity.ok("Logged out successfully");
}
```

**Redis Blacklist Storage:**
```
Key: blacklist_jti:{jti}
Value: true
TTL: token's remaining lifetime (max 10 hours)
```

**JTI Validation in blog-service:**
```java
@Component
public class TokenValidationFilter extends OncePerRequestFilter {
    protected void doFilterInternal(HttpServletRequest request, 
            HttpServletResponse response, FilterChain filterChain) {
        String token = extractToken(request);
        
        if (token != null && jwtUtil.validateToken(token)) {
            String jti = jwtUtil.extractJti(token);
            
            // Check if JTI is blacklisted
            if (isJtiBlacklisted(jti)) {
                response.setStatus(HttpStatus.FORBIDDEN.value());
                response.getWriter().write("Token has been revoked");
                return;
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

**Why JTI Blacklisting is Important:**

1. **Immediate Revocation** - User is immediately logged out across all services
2. **No Token Re-validation** - Only checks 36-byte JTI instead of re-validating entire token
3. **TTL-based Cleanup** - Redis automatically deletes expired entries (no background jobs)
4. **Distributed Validation** - All services check the same blacklist
5. **Memory Efficient** - JTI is much smaller than full token storage
6. **Security** - Prevents token replay attacks even if the token itself is stolen

**Comparison - Without JTI Blacklisting:**
- Token would remain valid until natural expiration (10 hours later)
- If token is stolen, attacker has 10 hours to use it
- No way to immediately revoke access

---

### Q22: How is the JWT secret managed and shared between services?

**Answer:**
The JWT secret is managed through environment variables:

**In docker-compose.yml:**
```yaml
environment:
  - JWT_SECRET=NTZhNDcyZTVkNDJhNDc2OTJkNzA3MjY4NzE1NjZkNDk0ZWIyNTQxNzYxNDc0NTZjNzA3MjY4NzE1NjZkNDk1OA==
```

**In application.properties (auth-service):**
```properties
jwt.secret=${JWT_SECRET:default-dev-secret}
```

**In application.properties (blog-service):**
```properties
jwt.secret=${JWT_SECRET:default-dev-secret}
```

**How Both Services Use It:**

Auth-service (Token Generation):
```java
@Value("${jwt.secret}")
private String secret;

private Key getSignInKey() {
    return Keys.hmacShaKeyFor(
        io.jsonwebtoken.io.Decoders.BASE64.decode(secret)
    );
}

// Token generation
String token = Jwts.builder()
    .setClaims(claims)
    .signWith(getSignInKey(), SignatureAlgorithm.HS256)
    .compact();
```

Blog-service (Token Validation):
```java
@Value("${jwt.secret}")
private String secret;

private Key getSignInKey() {
    return Keys.hmacShaKeyFor(
        io.jsonwebtoken.io.Decoders.BASE64.decode(secret)
    );
}

// Token validation
try {
    Jwts.parserBuilder()
        .setSigningKey(getSignInKey())
        .build()
        .parseClaimsJws(token);
    return true;
} catch (JwtException | IllegalArgumentException e) {
    return false;
}
```

**Security Best Practices:**

1. **Environment Variable** - Secret is not hardcoded, stored externally
2. **Base64 Encoding** - String is encoded to prevent special character issues
3. **Same Secret** - Both services use identical secret
4. **HS256 Algorithm** - HMAC-SHA256 is symmetric (same key for signing and verifying)
5. **Production Secret** - Should be:
   - Generated using a cryptographically secure random generator
   - At least 256 bits (32 bytes) long
   - Stored in secure secret management (AWS Secrets Manager, HashiCorp Vault)
   - Rotated periodically
   - Never committed to version control

**Secret Generation Command:**
```bash
openssl rand -base64 32
```

---

### Q23: What is CSRF protection, and how is it implemented in this system?

**Answer:**
CSRF (Cross-Site Request Forgery) is an attack where a malicious website tricks a user into making unwanted requests on another website where they're authenticated.

**Example Attack Without CSRF Protection:**
1. User logs into their bank (bank.com)
2. User visits a malicious site (evil.com) without logging out
3. evil.com sends: `<img src="http://bank.com/transfer?amount=1000&to=attacker">`
4. Browser automatically includes bank cookies
5. Bank processes the transfer without knowing it's malicious

**CSRF Protection Implementation in This System:**

**Token Generation (Backend):**
```java
// Nginx/Spring Security generates XSRF token
response.addHeader("Set-Cookie", "XSRF-TOKEN=xyz123; HttpOnly");
```

**Frontend Request Interceptor:**
```typescript
api.interceptors.request.use((config) => {
    const csrfToken = getCsrfToken();
    if (csrfToken && ['post', 'put', 'delete'].includes(config.method)) {
        config.headers['X-XSRF-TOKEN'] = csrfToken;
    }
    return config;
});
```

**Backend Validation:**
```java
// Spring Security checks CSRF token
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) {
        http.csrf(csrf -> csrf.csrfTokenRepository(csrfTokenRepository()));
        // ...
    }
}
```

**Why This Works:**

1. **Token in Cookie** - XSRF-TOKEN stored as standard (not HttpOnly) cookie
2. **Token in Header** - Frontend reads cookie and sends token in X-XSRF-TOKEN header
3. **Same-Origin Restriction** - Malicious sites cannot read cookies (same-origin policy)
4. **GET is Safe** - CSRF protection only for POST/PUT/DELETE
5. **Automatic Validation** - Spring Security compares cookie token with header token

**Attack Prevented:**
1. Attacker's site cannot read XSRF-TOKEN cookie (same-origin policy)
2. Attacker cannot send request with correct X-XSRF-TOKEN header
3. Bank rejects request because header token is missing/invalid
4. Transfer is not processed

**Important:** This system uses both:
- **HttpOnly JWT Cookie** (prevents XSS)
- **XSRF Token in Header** (prevents CSRF)

---

### Q24: How does the system prevent XSS (Cross-Site Scripting) attacks?

**Answer:**
XSS attacks inject malicious JavaScript into web pages. The system uses multiple layers of defense:

**Layer 1: HttpOnly Cookies**
```typescript
// JWT stored as HttpOnly cookie - cannot be accessed by JavaScript
withCredentials: true, // Browser automatically sends cookies
```

Even if attacker injects JavaScript:
```javascript
// This will NOT work
console.log(document.cookie); // Empty (HttpOnly blocks access)
fetch('/api/articles', {
    credentials: 'include' // Browser sends JWT automatically
});
```

**Layer 2: Content Security Policy (CSP)**
```
// Should be set in response headers:
Content-Security-Policy: default-src 'self'; script-src 'self'
```
- Only allows scripts from same origin
- Blocks inline scripts
- Prevents data: and javascript: URLs

**Layer 3: Input Sanitization**
```typescript
// Frontend sanitization
import DOMPurify from 'dompurify';

<div>{escapeHtml(article.title)}</div>

// In ArticleList.tsx
{escapeHtml(article.title)}
```

**Layer 4: Output Encoding**
```typescript
function escapeHtml(text: string): string {
    const map: { [key: string]: string } = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;',
    };
    return text.replace(/[&<>"']/g, (char) => map[char]);
}
```

**Layer 5: Backend Output Encoding**
```java
// Spring automatically encodes JSON values in responses
// ArticleDto fields are XML/JSON encoded before transmission
```

**Example - How These Protect:**

Attacker tries to inject:
```html
<img src="x" onerror="fetch('/api/articles', {credentials: 'include'})">
```

**Protection Applied:**
1. If stored in database and displayed, output encoding escapes it:
   ```
   &lt;img src=&quot;x&quot; onerror=&quot;fetch(...&quot;&gt;
   ```
2. Browser renders as text, not HTML
3. No JavaScript execution
4. Even if executed, HttpOnly cookie prevents token access
5. CSP prevents external fetch calls

---

### Q25: What are refresh tokens, and how do they work in this system?

**Answer:**
Refresh tokens are long-lived tokens that enable users to stay logged in without re-entering credentials.

**Token Lifetimes:**
- **Access Token (JWT)** - 10 hours, used for API requests
- **Refresh Token** - 7 days, used only to get new access tokens

**Workflow:**

**Initial Login:**
```
Client                    Auth-Service               Redis
  |                             |                       |
  |---POST /auth/login--------->|                       |
  |                             |--(hash verify)-----   |
  |                             |                       |
  |<--JWT + Refresh Token--------|                       |
  |                             |--store refresh token-->|
  |                             |                        |
```

```java
String token = jwtUtil.generateToken(user); // 10-hour expiration
String refreshToken = generateRefreshToken(user); // 7-day expiration
tokenCacheService.storeRefreshToken(user.getUsername(), refreshToken, 7 * 24 * 60 * 60 * 1000);

return new AuthResponse(token, refreshToken, user.getEmail());
```

**Using Refresh Token:**
```java
@PostMapping("/auth/refresh")
public ResponseEntity<AuthResponse> refreshAccessToken(
    @RequestBody RefreshTokenRequest request) {
    
    String refreshToken = request.getRefreshToken();
    
    // Validate refresh token in Redis
    if (!tokenCacheService.isRefreshTokenValid(refreshToken)) {
        return ResponseEntity.status(401).build();
    }
    
    // Generate new access token
    String newAccessToken = jwtUtil.generateToken(user);
    
    return ResponseEntity.ok(new AuthResponse(newAccessToken));
}
```

**Benefits:**

1. **Security** - Short-lived JWT limits damage if stolen
2. **User Experience** - Long-lived refresh token enables seamless login
3. **Revocation** - Refresh tokens can be blacklisted independently
4. **Rotation** - Access tokens change frequently
5. **Server Control** - Server can invalidate refresh tokens

**Logout Affects Both:**
```java
// Logout blacklists both tokens
tokenCacheService.blacklistToken(accessTokenJti, remainingTime);
tokenCacheService.invalidateRefreshToken(username);
```

**Frontend Implementation:**
```typescript
// Axios interceptor could auto-refresh:
api.interceptors.response.use(
    response => response,
    async error => {
        if (error.response?.status === 401) {
            const newToken = await api.post('/auth/refresh', {
                refreshToken: getRefreshToken()
            });
            // Retry original request with new token
        }
    }
);
```

---

## Database & Caching

### Q26: What is the database schema, and how are the tables related?

**Answer:**
The shared PostgreSQL database has the following structure:

**Users Table:**
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL, -- ENUM: ADMIN, USER
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Articles Table:**
```sql
CREATE TABLE articles (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    tags VARCHAR(100),
    publish_status VARCHAR(50) NOT NULL, -- 'draft' or 'published'
    author_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE
);
```

**Relationships:**

```
┌─────────────┐         ┌──────────────┐
│   users     │         │   articles   │
├─────────────┤         ├──────────────┤
│ id (PK)     │<────┬───│ id (PK)      │
│ email       │     │   │ title        │
│ password    │     │   │ content      │
│ role        │     │   │ tags         │
│ created_at  │     │   │ publish_status
│             │     │   │ author_id(FK)│
└─────────────┘     │   │ created_at   │
                    │   │ updated_at   │
                    │   └──────────────┘
                    │
                    └── One-to-Many
                        (User has many Articles)
```

**Constraints:**
- `email` is UNIQUE in users table
- `author_id` is FOREIGN KEY (not nullable)
- `ON DELETE CASCADE` means deleting a user deletes their articles
- `publish_status` only allows 'draft' or 'published'

**JPA Entity Mapping (blog-service):**
```java
@Entity
@Table(name = "articles")
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;
    
    @ManyToOne
    @JoinColumn(name = "author_id")
    private User author; // References users table
    
    @CreationTimestamp
    private Instant createdAt;
    
    @UpdateTimestamp
    private Instant updatedAt;
}
```

**Indexes for Performance:**
```sql
CREATE INDEX idx_articles_author_id ON articles(author_id);
CREATE INDEX idx_articles_title ON articles(title);
CREATE INDEX idx_users_email ON users(email);
```

---

### Q27: How is Redis used for different purposes in the system?

**Answer:**
Redis serves multiple purposes with two separate instances:

**Auth-Cache (Shared - Port 6380):**

1. **JTI Blacklist:**
```
Key: blacklist_jti:{jti}
Value: true
TTL: remaining token lifetime (max 10 hours)
```
- Stores revoked JWT tokens
- Used by both auth-service and blog-service
- Prevents reuse of logged-out tokens

2. **Refresh Token Storage:**
```
Key: refresh_token:{username}
Value: {refresh_token}
TTL: 7 days
```
- Stores refresh tokens for token renewal
- Used by auth-service only

3. **Session Storage:**
```
Key: session:{username}
Value: {user_email}
TTL: 1 hour
```
- Tracks active user sessions
- Used by auth-service for session validation

4. **Rate Limit Counters:**
```
Key: ratelimit:login:{ip}
Value: {attempt_count}
TTL: 60 seconds (window)
```
- Tracks login attempts per IP
- Used by RateLimitFilter to prevent brute-force

**Blog-Cache (Local - Port 6379):**

1. **Article Data Cache:**
```
Key: articles::{article_id}
Value: {ArticleDto as JSON}
TTL: configurable (default 1 hour)
```
- Caches full article objects
- Reduces database queries
- Evicted on update/delete
- Used by blog-service only

**Configuration:**

Auth-service `application.properties`:
```properties
spring.redis.host=auth-cache
spring.redis.port=6379
spring.redis.timeout=2000
spring.cache.type=redis
```

Blog-service `application.properties`:
```properties
spring.redis.host=blog-cache
spring.redis.port=6379
spring.cache.type=redis
```

**Comparison:**

| Purpose | Instance | Type | TTL | Scope |
|---------|----------|------|-----|-------|
| JTI Blacklist | Auth-Cache | Set | Token lifetime | Both services |
| Refresh Token | Auth-Cache | String | 7 days | Auth service |
| Session | Auth-Cache | String | 1 hour | Auth service |
| Rate Limit | Auth-Cache | Counter | 60 sec | Auth service |
| Article Cache | Blog-Cache | Hash | Configurable | Blog service |

**Why Separate Instances:**
- Auth-cache is shared (both services read JTI blacklist)
- Blog-cache is local (only blog-service uses it)
- Allows independent scaling
- Reduces contention for shared auth-cache

---

### Q28: How does pagination work in the article listing?

**Answer:**
The system uses Spring Data JPA's `Pageable` interface for pagination:

**Backend Implementation:**
```java
@GetMapping
@PreAuthorize("isAuthenticated()")
public ResponseEntity<Page<ArticleSummaryDto>> listArticles(
    @RequestParam(required = false) String title,
    @PageableDefault(size = 10) Pageable pageable) {
    
    Page<ArticleSummaryDto> articles = articleService.getAllArticles(title, pageable);
    return ResponseEntity.ok(articles);
}
```

**Service Layer:**
```java
public Page<ArticleSummaryDto> getAllArticles(String title, Pageable pageable) {
    User currentUser = getCurrentUser();
    boolean isAdmin = isAdmin(currentUser);
    
    if (isAdmin) {
        if (title != null) {
            articles = articleRepository.findByTitleContainingIgnoreCase(title, pageable);
        } else {
            articles = articleRepository.findAll(pageable);
        }
    } else {
        // Non-admin users see only their articles
        if (title != null) {
            articles = articleRepository.findByAuthorAndTitleContainingIgnoreCase(
                currentUser, title, pageable
            );
        } else {
            articles = articleRepository.findByAuthor(currentUser, pageable);
        }
    }
    
    return articles.map(articleMapper::toSummaryDto);
}
```

**Repository Queries:**
```java
@Repository
public interface ArticleRepository extends JpaRepository<Article, Long> {
    Page<Article> findAll(Pageable pageable);
    
    Page<Article> findByTitleContainingIgnoreCase(String title, Pageable pageable);
    
    Page<Article> findByAuthor(User author, Pageable pageable);
    
    Page<Article> findByAuthorAndTitleContainingIgnoreCase(
        User author, String title, Pageable pageable
    );
}
```

**Frontend Implementation:**
```typescript
const [page, setPage] = useState(0);
const [totalPages, setTotalPages] = useState(0);

const fetchArticles = async () => {
    const response = await api.get(`/articles?title=${search}&page=${page}&size=5`);
    setArticles(response.data.content); // Array of articles
    setTotalPages(response.data.totalPages); // Total pages
};

<button onClick={() => setPage(page - 1)} disabled={page === 0}>
    Previous
</button>
<span>Page {page + 1} of {totalPages}</span>
<button onClick={() => setPage(page + 1)} disabled={page === totalPages - 1}>
    Next
</button>
```

**API Response Format:**
```json
{
    "content": [
        {
            "id": 1,
            "title": "First Article",
            "tags": "react,typescript",
            "publishStatus": "published",
            "authorEmail": "user@example.com",
            "createdAt": "2026-01-01T10:00:00Z"
        }
    ],
    "pageable": {
        "pageNumber": 0,
        "pageSize": 5
    },
    "totalElements": 25,
    "totalPages": 5,
    "last": false,
    "first": true,
    "empty": false
}
```

**Pagination Strategies:**

1. **Offset-Based (Current)** - Skip N records, take M
   - Simple but slow for large offsets
   - Good for small datasets

2. **Cursor-Based** - Use last ID as reference
   - Better for large datasets
   - Doesn't skip records

3. **Keyset Pagination** - Use multiple columns as cursor
   - Most efficient for large datasets
   - Complex to implement

---

### Q29: How does the database handle concurrent article updates?

**Answer:**
The system handles concurrency through optimistic locking and retry logic:

**Optimistic Locking Implementation:**
```java
@Entity
@Table(name = "articles")
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Version
    private Long version; // Optimistic lock version
    
    private String title;
    private String content;
    // ...
}
```

**How It Works:**

1. **Read Article:**
```
User A reads Article (version = 1)
User B reads Article (version = 1)
```

2. **Update by User A:**
```
User A updates and saves (version 1 → 2)
UPDATE articles SET version=2, title='...' WHERE id=1 AND version=1
-- Success, version incremented
```

3. **Update by User B:**
```
User B tries to save (version 1 → 2)
UPDATE articles SET version=2, title='...' WHERE id=1 AND version=1
-- Fails! Version is now 2, not 1
-- Throws OptimisticLockingFailureException
```

**Service Layer Handling:**
```java
@Transactional
@PreAuthorize("hasRole('ADMIN') or @articleSecurity.isOwner(authentication, #id)")
@Retryable(
    retryFor = {
        org.springframework.dao.ConcurrencyFailureException.class,
        // ... other exceptions
    },
    maxAttempts = 3,
    backoff = @Backoff(delay = 100, multiplier = 2)
)
public ArticleDto updateArticle(Long id, ArticleDto dto) {
    Article article = articleRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Not found"));
    
    article.setTitle(dto.getTitle());
    article.setContent(dto.getContent());
    
    Article saved = articleRepository.save(article); // May throw if version conflict
    return articleMapper.toDto(saved);
}
```

**Retry Behavior:**
- First attempt fails with ConcurrencyFailureException
- Waits 100ms, retries
- Reads latest version (now 2)
- Retries with correct version
- Success on retry

**Alternative: Pessimistic Locking:**
```java
@Query("SELECT a FROM Article a WHERE a.id = :id")
@Lock(LockModeType.PESSIMISTIC_WRITE)
Article findByIdForUpdate(Long id);
```
- Locks row immediately (slower)
- Prevents conflicts but serializes updates
- Better for frequent conflicts

**Which to Use:**
- **Optimistic** - Few conflicts expected (typical case)
- **Pessimistic** - Many conflicts expected (high contention)

---

### Q30: How does the mapper handle data transformation between entities and DTOs?

**Answer:**
The `ArticleMapper` converts between JPA entities and DTOs (Data Transfer Objects):

**Mapper Interface:**
```java
@Component
public interface ArticleMapper {
    ArticleDto toDto(Article article);
    ArticleSummaryDto toSummaryDto(Article article);
}
```

**Implementation:**
```java
@Component
public class ArticleMapperImpl implements ArticleMapper {
    
    @Override
    public ArticleDto toDto(Article article) {
        ArticleDto dto = new ArticleDto();
        dto.setId(article.getId());
        dto.setTitle(article.getTitle());
        dto.setContent(article.getContent());
        dto.setTags(article.getTags());
        dto.setPublishStatus(article.getPublishStatus());
        dto.setCreatedAt(article.getCreatedAt());
        dto.setUpdatedAt(article.getUpdatedAt());
        
        if (article.getAuthor() != null) {
            dto.setAuthorId(article.getAuthor().getId());
            dto.setAuthorEmail(article.getAuthor().getEmail());
        }
        
        return dto;
    }
    
    @Override
    public ArticleSummaryDto toSummaryDto(Article article) {
        ArticleSummaryDto dto = new ArticleSummaryDto();
        dto.setId(article.getId());
        dto.setTitle(article.getTitle());
        // Note: content is NOT included in summary
        dto.setTags(article.getTags());
        dto.setPublishStatus(article.getPublishStatus());
        // ... similar mapping
        return dto;
    }
}
```

**DTOs:**
```java
@Data
public class ArticleDto {
    private Long id;
    @NotBlank(message = "Title is required")
    @Size(min = 1, max = 200, message = "Title must be 1-200 chars")
    private String title;
    
    @NotBlank(message = "Content is required")
    @Size(min = 1, max = 20000, message = "Content must be 1-20000 chars")
    private String content;
    
    @Pattern(regexp = "^(draft|published)$", message = "Must be 'draft' or 'published'")
    private String publishStatus;
    
    // author_id and author_email for response
    private Long authorId;
    private String authorEmail;
}

@Data
public class ArticleSummaryDto {
    private Long id;
    private String title;
    // content is intentionally excluded
    private String tags;
    private String publishStatus;
    private Long authorId;
    private String authorEmail;
}
```

**Why Use Mappers:**

1. **Separation of Concerns** - Entity contains all fields, DTO only what's needed
2. **API Contract** - DTO defines what's sent to clients (content not in list)
3. **Validation** - DTOs have validation annotations
4. **Performance** - Summary DTO excludes large content field
5. **Security** - Can exclude sensitive fields (e.g., password)
6. **Evolution** - Can change DTO without changing entity

**Usage:**
```java
// Service layer
Page<Article> articles = articleRepository.findAll(pageable);
return articles.map(articleMapper::toSummaryDto);

// REST returns ArticleSummaryDto (without content)
// GET /articles/{id} returns ArticleDto (with content)
```

---

## DevOps & Docker

### Q31: How is the application deployed using Docker Compose?

**Answer:**
Docker Compose orchestrates all services defined in `docker-compose.yml`:

**Service Architecture:**
```yaml
services:
  auth-service:
    build: ./auth-service
    ports: ["8081:8081"]
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - DB_HOST=database
      - REDIS_HOST=auth-cache
    depends_on:
      database: { condition: service_healthy }
      auth-cache: { condition: service_healthy }

  blog-service:
    build: ./blog-service
    ports: ["8082:8082"]
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - DB_HOST=database
      - SPRING_REDIS_HOST=auth-cache
    depends_on:
      database: { condition: service_healthy }
      auth-cache: { condition: service_healthy }

  frontend:
    build:
      context: ./frontend
      args:
        - REACT_APP_API_URL=/api
    ports: ["8080:80"]
    depends_on:
      - auth-service
      - blog-service

  database:
    image: postgres:16
    ports: ["5432:5432"]
    environment:
      - POSTGRES_DB=appdb
      - POSTGRES_PASSWORD=password
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]

  auth-cache:
    build: ./auth-cache
    ports: ["6380:6379"]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]

  blog-cache:
    build: ./blog-cache
    ports: ["6379:6379"]
```

**Startup Sequence:**
```
docker-compose up --build

1. Build services (if --build flag)
2. Create network (app-network)
3. Start database
4. Database runs healthcheck (pg_isready)
5. Start auth-cache
6. Start blog-cache
7. Start auth-service (waits for database healthy)
8. Start blog-service (waits for database healthy)
9. Start frontend (waits for services ready)
10. All services healthy, application ready
```

**Volumes:**
```yaml
volumes:
  db-data:  # Persists PostgreSQL data between container restarts
```

**Environment Variables:**
```bash
# Set via .env file or command line
JWT_SECRET=base64-encoded-secret
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=password123
```

**Common Commands:**
```bash
# Start all services
docker-compose up

# Start in background
docker-compose up -d

# View logs
docker-compose logs -f auth-service
docker-compose logs -f blog-service
docker-compose logs -f frontend

# Stop services
docker-compose down

# Stop and remove volumes
docker-compose down -v

# Rebuild after code changes
docker-compose up --build

# Rebuild specific service
docker-compose build auth-service

# Execute command in running container
docker-compose exec auth-service bash
docker-compose exec database psql -U postgres appdb
```

---

### Q32: How is the frontend built and served by Nginx?

**Answer:**
The frontend is a React app compiled to static assets and served by Nginx:

**Dockerfile:**
```dockerfile
# Build stage
FROM node:21-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build  # Creates build/ directory with static files

# Runtime stage
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**Nginx Configuration:**
```nginx
server {
    listen 80;

    # Serve static files (HTML, CSS, JS)
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;  # SPA routing
    }

    # Proxy auth endpoints to auth-service
    location /api/auth/ {
        proxy_pass http://auth-service:8081/auth/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Proxy article endpoints to blog-service
    location /api/articles {
        proxy_pass http://blog-service:8082/articles;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**SPA Routing:**
```nginx
try_files $uri $uri/ /index.html;
```
- Requests `/articles` → checks if `/articles` file exists
- If not, checks if `/articles` directory exists
- If not, serves `/index.html`
- React Router then handles client-side routing

**Proxy Headers:**
- `Host` - Forwards original host to backend
- `X-Real-IP` - Preserves client IP (not Nginx's IP)
- `X-Forwarded-For` - List of IPs (client → proxies)
- `X-Forwarded-Proto` - Original protocol (http/https)

**Build Environment Variables:**
```dockerfile
ARG REACT_APP_API_URL=/api  # API base path
```

**Frontend Request Flow:**
```
1. User goes to http://localhost:8080
2. Nginx serves index.html from /usr/share/nginx/html
3. Browser loads React app
4. User clicks "Create Article"
5. React calls api.post('/articles', data)
6. Axios sends to http://localhost:8080/api/articles (relative URL)
7. Nginx intercepts /api/articles
8. Proxies to http://blog-service:8082/articles
9. Blog service processes request
10. Response returned to Nginx
11. Nginx forwards to browser
12. React updates UI
```

---

### Q33: How are the Java services built using Maven?

**Answer:**
Both auth-service and blog-service use Maven for dependency management and building:

**Dockerfile (for Java services):**
```dockerfile
# Build stage
FROM maven:3.9.9-amazoncorretto-21 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B  # Download dependencies (cached layer)
COPY src ./src
RUN mvn clean package -DskipTests  # Build JAR

# Runtime stage
FROM amazoncorretto:21-alpine
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
ENV SERVER_PORT=8082
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Multi-Stage Build Benefits:**
1. **First Stage (Build)** - Heavy: Maven, compiler, dependencies
2. **Second Stage (Runtime)** - Light: Only Java runtime + app.jar
3. **Result** - Smaller image (multi-stage is ~200MB vs 500MB with everything)
4. **Security** - Build tools not in production image

**pom.xml Structure:**
```xml
<project>
    <groupId>com.example</groupId>
    <artifactId>blog-service</artifactId>
    <version>1.0.0</version>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.2</version>
    </parent>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <!-- ... more dependencies -->
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

**Maven Build Process:**
```bash
# Local development
cd auth-service
./mvnw clean package -DskipTests
# Creates: target/auth-service-1.0.0.jar

# Spring Boot run
./mvnw spring-boot:run

# With custom properties
./mvnw spring-boot:run -Dspring-boot.run.arguments="--server.port=8888"

# Tests
./mvnw test
./mvnw test -Dtest=AuthServiceTest  # Specific test
```

**Docker Build:**
```bash
# Build service image
docker-compose build auth-service

# Then start
docker-compose up auth-service
```

---

### Q34: How are environment variables managed in the containerized deployment?

**Answer:**
Environment variables are managed through multiple layers:

**docker-compose.yml:**
```yaml
services:
  auth-service:
    environment:
      - SERVER_PORT=8081
      - DB_HOST=database
      - DB_PORT=5432
      - DB_NAME=appdb
      - DB_USERNAME=postgres
      - DB_PASSWORD=password
      - JWT_SECRET=${JWT_SECRET}  # From .env file
      - JWT_EXPIRATION=86400000
      - ADMIN_EMAIL=${ADMIN_EMAIL:-admin@example.com}  # Default fallback
      - ADMIN_PASSWORD=${ADMIN_PASSWORD:-password123}
      - REDIS_HOST=auth-cache
      - REDIS_PORT=6379
```

**.env file:**
```env
JWT_SECRET=NTZhNDcyZTVkNDJhNDc2OTJkNzA3MjY4NzE1NjZkNDk0ZWIyNTQxNzYxNDc0NTZjNzA3MjY4NzE1NjZkNDk1OA==
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=password123
REDIS_PASSWORD=
```

**application.properties (auth-service):**
```properties
server.port=${SERVER_PORT:8081}
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:appdb}
spring.datasource.username=${DB_USERNAME:postgres}
spring.datasource.password=${DB_PASSWORD:password}
jwt.secret=${JWT_SECRET:default-secret}
jwt.expiration=${JWT_EXPIRATION:36000000}
admin.email=${ADMIN_EMAIL:admin@example.com}
admin.password=${ADMIN_PASSWORD:password123}
cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:8080}
```

**Variable Resolution Priority:**

```
1. Environment variable (from docker-compose.yml)
   ↓
2. System property (from JVM -D flag)
   ↓
3. Default in application.properties (colon notation)
   ↓
4. Hardcoded default in code
```

**Example Resolution:**
```
${JWT_SECRET}
↓
Look in Docker environment: JWT_SECRET=xyz
↓
Use: xyz
```

```
${ADMIN_EMAIL:-admin@example.com}
↓
Look in Docker environment: ADMIN_EMAIL not set
↓
Use default: admin@example.com
```

**Development vs Production:**

**Development (docker-compose.yml):**
```yaml
environment:
  - JWT_SECRET=dev-secret
  - ADMIN_PASSWORD=password123  # Weak password OK for dev
```

**Production (not in repo, provided separately):**
```bash
# Via .env file (not in version control):
JWT_SECRET=<strong-random-secret>
ADMIN_PASSWORD=<strong-random-password>

# Or via CI/CD secrets:
docker-compose -f docker-compose.yml \
  -e JWT_SECRET=$GITHUB_SECRET_JWT \
  -e ADMIN_PASSWORD=$GITHUB_SECRET_PASSWORD \
  up
```

**Best Practices:**
1. Never commit `.env` to version control
2. Use strong random values for secrets (use `openssl rand -base64 32`)
3. Different secrets for dev/prod
4. Use secrets management (AWS Secrets Manager, HashiCorp Vault)
5. Rotate secrets periodically
6. Don't echo secrets in logs

---

### Q35: How are database migrations and schema management handled?

**Answer:**
Database schema is managed through JPA's `ddl-auto` property:

**Configuration in application.properties:**
```properties
spring.jpa.hibernate.ddl-auto=${DDL_AUTO:update}
```

**DDL Auto Modes:**

1. **create** - Drop all tables and create from scratch (dev only!)
   ```properties
   spring.jpa.hibernate.ddl-auto=create
   # On startup: DROP TABLE articles; CREATE TABLE articles;
   ```

2. **create-drop** - Create on startup, drop on shutdown
   ```properties
   spring.jpa.hibernate.ddl-auto=create-drop
   # Useful for testing (clean slate each run)
   ```

3. **update** - Alter existing tables (add columns, not drop) - Current setting
   ```properties
   spring.jpa.hibernate.ddl-auto=update
   # Safe for development
   # Adds new columns but doesn't remove unused ones
   ```

4. **validate** - Check if schema matches entities (production)
   ```properties
   spring.jpa.hibernate.ddl-auto=validate
   # If mismatch, throws error (prevents data loss)
   ```

5. **none** - Do nothing
   ```properties
   spring.jpa.hibernate.ddl-auto=none
   # Manual migration management only
   ```

**Current Development Approach:**
```yaml
services:
  auth-service:
    environment:
      - DDL_AUTO=update  # Auto-update schema on startup
```

**JPA Entity Definitions:**
```java
@Entity
@Table(name = "articles")
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;
    
    @CreationTimestamp
    private Instant createdAt;
    
    @UpdateTimestamp
    private Instant updatedAt;
}
```

**Generated SQL:**
```sql
-- Hibernate generates from Entity
CREATE TABLE articles (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**Database Initialization:**
```dockerfile
# database/Dockerfile
FROM postgres:16
COPY init.sql /docker-entrypoint-initdb.d/
```

```sql
-- database/init.sql
-- Only creates database and users, Hibernate creates tables
CREATE DATABASE appdb;
GRANT ALL PRIVILEGES ON DATABASE appdb TO postgres;
```

**Production Migration Strategy:**

For production, use Flyway or Liquibase:
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

```properties
# application-prod.properties
spring.jpa.hibernate.ddl-auto=validate  # Don't auto-create
spring.flyway.locations=classpath:db/migration
spring.flyway.baselineOnMigrate=true
```

```
src/main/resources/db/migration/
├── V1__initial_schema.sql
├── V2__add_article_tags.sql
├── V3__add_article_status.sql
```

**Why Not ddl-auto in Production:**
- `update` can silently fail or cause data loss
- No version control of schema changes
- Cannot rollback
- Multiple instances updating schema simultaneously is dangerous
- Flyway/Liquibase provide audit trail and safety

---

## Advanced Topics

### Q36: How would you implement search functionality across articles?

**Answer:**
Full-text search could be implemented in multiple ways:

**Option 1: Database LIKE Query (Current)**
```java
@Repository
public interface ArticleRepository extends JpaRepository<Article, Long> {
    Page<Article> findByTitleContainingIgnoreCase(String title, Pageable pageable);
}

// Usage
articles = articleRepository.findByTitleContainingIgnoreCase(searchTerm, pageable);
```

**Limitations:**
- Case-insensitive only (no accent handling)
- No relevance ranking
- Slow on large datasets (table scans)
- No word stemming

**Option 2: PostgreSQL Full-Text Search**
```java
@Repository
public interface ArticleRepository extends JpaRepository<Article, Long> {
    @Query(value = "SELECT a FROM Article a " +
           "WHERE to_tsvector('english', a.title || ' ' || a.content) " +
           "@@ plainto_tsquery('english', :searchTerm)")
    Page<Article> fullTextSearch(@Param("searchTerm") String searchTerm, Pageable pageable);
}
```

```sql
-- Native query
SELECT id, title, content
FROM articles
WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', 'spring boot')
ORDER BY ts_rank(to_tsvector('english', title || ' ' || content), plainto_tsquery('english', 'spring boot')) DESC;
```

**Benefits:**
- Word stemming (run → running, ran)
- Accent handling
- Relevance ranking
- Faster than LIKE
- No external dependencies

**Option 3: Elasticsearch**
```java
@Configuration
public class ElasticsearchConfig {
    @Bean
    public RestHighLevelClient client() {
        return new RestHighLevelClient(
            RestClient.builder(new HttpHost("elasticsearch", 9200))
        );
    }
}

@Service
public class ArticleSearchService {
    private final RestHighLevelClient client;
    
    public List<Article> search(String query) throws IOException {
        SearchRequest searchRequest = new SearchRequest("articles");
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.query(QueryBuilders.matchQuery("title", query));
        searchRequest.source(sourceBuilder);
        
        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);
        // Parse response...
    }
}
```

**Advantages:**
- Best for large-scale search
- Faceted search (categories, dates)
- Fuzzy search (typo tolerance)
- Complex queries
- Real-time indexing

**Implementation Plan:**
1. Start with current LIKE (simple, works)
2. Add PostgreSQL full-text search (better, no dependency)
3. Migrate to Elasticsearch if needed (scale)

---

### Q37: How would you implement article versioning/history?

**Answer:**
Track article changes over time:

**Database Schema:**
```sql
CREATE TABLE article_versions (
    id BIGSERIAL PRIMARY KEY,
    article_id BIGINT NOT NULL,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    tags VARCHAR(100),
    publish_status VARCHAR(50),
    changed_by BIGINT NOT NULL,
    change_reason VARCHAR(500),
    changed_at TIMESTAMP NOT NULL,
    FOREIGN KEY (article_id) REFERENCES articles(id),
    FOREIGN KEY (changed_by) REFERENCES users(id),
    INDEX idx_article_id (article_id)
);
```

**JPA Entity:**
```java
@Entity
@Table(name = "article_versions")
public class ArticleVersion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "article_id", nullable = false)
    private Long articleId;
    
    private String title;
    private String content;
    private String publishStatus;
    
    @ManyToOne
    @JoinColumn(name = "changed_by")
    private User changedBy;
    
    private String changeReason;
    
    @CreationTimestamp
    private Instant changedAt;
}
```

**Service Implementation:**
```java
@Service
public class ArticleService {
    private final ArticleRepository articleRepository;
    private final ArticleVersionRepository versionRepository;
    
    @Transactional
    public ArticleDto updateArticle(Long id, ArticleDto dto) {
        Article article = articleRepository.findById(id).orElseThrow();
        
        // Create version before update
        saveVersion(article, getCurrentUser(), "Updated article");
        
        // Update article
        article.setTitle(dto.getTitle());
        article.setContent(dto.getContent());
        articleRepository.save(article);
        
        return articleMapper.toDto(article);
    }
    
    private void saveVersion(Article article, User user, String reason) {
        ArticleVersion version = new ArticleVersion();
        version.setArticleId(article.getId());
        version.setTitle(article.getTitle());
        version.setContent(article.getContent());
        version.setPublishStatus(article.getPublishStatus());
        version.setChangedBy(user);
        version.setChangeReason(reason);
        versionRepository.save(version);
    }
    
    public List<ArticleVersion> getArticleHistory(Long articleId) {
        return versionRepository.findByArticleIdOrderByChangedAtDesc(articleId);
    }
    
    public ArticleDto restoreVersion(Long articleId, Long versionId) {
        ArticleVersion version = versionRepository.findById(versionId).orElseThrow();
        Article article = articleRepository.findById(articleId).orElseThrow();
        
        // Save current as version before restoring
        saveVersion(article, getCurrentUser(), "Restored from version " + versionId);
        
        // Restore
        article.setTitle(version.getTitle());
        article.setContent(version.getContent());
        articleRepository.save(article);
        
        return articleMapper.toDto(article);
    }
}
```

**API Endpoints:**
```java
@GetMapping("/{id}/history")
public ResponseEntity<List<ArticleVersionDto>> getHistory(@PathVariable Long id) {
    return ResponseEntity.ok(articleService.getArticleHistory(id));
}

@PostMapping("/{id}/restore/{versionId}")
public ResponseEntity<ArticleDto> restoreVersion(
    @PathVariable Long id,
    @PathVariable Long versionId) {
    return ResponseEntity.ok(articleService.restoreVersion(id, versionId));
}
```

---

### Q38: How would you implement email notifications?

**Answer:**
Send email notifications for user actions:

**Dependencies:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

**Configuration:**
```properties
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=${MAIL_USERNAME}
spring.mail.password=${MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
```

**Email Service:**
```java
@Service
public class EmailService {
    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;
    
    public void sendWelcomeEmail(User user) {
        String subject = "Welcome to Blog Admin System";
        String content = buildWelcomeEmailContent(user);
        
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(user.getEmail());
        message.setSubject(subject);
        message.setText(content);
        
        mailSender.send(message);
    }
    
    public void sendArticlePublishedNotification(Article article, User subscriber) {
        // Template context
        Context context = new Context();
        context.setVariable("article", article);
        context.setVariable("author", article.getAuthor().getEmail());
        
        // Process template
        String content = templateEngine.process("email/article-published", context);
        
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
        helper.setTo(subscriber.getEmail());
        helper.setSubject("New Article: " + article.getTitle());
        helper.setText(content, true);
        
        mailSender.send(message);
    }
}
```

**Template (resources/templates/email/article-published.html):**
```html
<!DOCTYPE html>
<html>
<body>
    <h2>New Article Published!</h2>
    <p>Author <strong th:text="${author}"></strong> published:</p>
    <h3 th:text="${article.title}"></h3>
    <p th:text="${article.content}"></p>
    <a href="http://localhost:8080/articles">Read more</a>
</body>
</html>
```

**Usage in Article Service:**
```java
@Transactional
public ArticleDto createArticle(ArticleDto dto) {
    Article article = new Article();
    article.setTitle(dto.getTitle());
    article.setPublishStatus(dto.getPublishStatus());
    article.setAuthor(getCurrentUser());
    
    Article saved = articleRepository.save(article);
    
    // Send notification if published
    if ("published".equals(dto.getPublishStatus())) {
        emailService.sendArticlePublishedNotification(saved);
    }
    
    return articleMapper.toDto(saved);
}
```

---

### Q39: How would you add multi-language support?

**Answer:**
Implement i18n (internationalization) using Spring's MessageSource:

**File Structure:**
```
resources/
├── messages.properties          # Default (English)
├── messages_es.properties       # Spanish
├── messages_fr.properties       # French
└── messages_de.properties       # German
```

**messages.properties:**
```properties
article.title=Title
article.content=Content
article.publish=Publish
article.published=Article published successfully
error.article.not_found=Article not found
```

**messages_es.properties:**
```properties
article.title=Título
article.content=Contenido
article.publish=Publicar
article.published=Artículo publicado con éxito
error.article.not_found=Artículo no encontrado
```

**Spring Configuration:**
```java
@Configuration
public class I18nConfig {
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("classpath:messages");
        messageSource.setDefaultEncoding(StandardCharsets.UTF_8.name());
        messageSource.setCacheSeconds(3600);
        return messageSource;
    }
    
    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.ENGLISH);
        return resolver;
    }
    
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang");
        return interceptor;
    }
}
```

**Controller Usage:**
```java
@RestController
public class ArticleController {
    @Autowired
    private MessageSource messageSource;
    
    @PostMapping
    public ResponseEntity<ArticleDto> createArticle(
        @RequestBody ArticleDto dto,
        Locale locale) {
        
        ArticleDto created = articleService.createArticle(dto);
        
        String message = messageSource.getMessage(
            "article.published",
            null,
            locale
        );
        
        return ResponseEntity.ok(created);
    }
}
```

**API Usage:**
```
GET /api/articles?lang=es      # Spanish
GET /api/articles?lang=fr      # French
GET /api/articles               # Default (English)
```

---

### Q40: How would you implement audit logging?

**Answer:**
Track all changes for compliance and debugging:

**Database Schema:**
```sql
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(100) NOT NULL,
    entity_id BIGINT NOT NULL,
    action VARCHAR(50) NOT NULL,  -- CREATE, UPDATE, DELETE
    user_id BIGINT,
    old_values JSON,
    new_values JSON,
    timestamp TIMESTAMP NOT NULL,
    ip_address VARCHAR(45),
    INDEX idx_entity (entity_type, entity_id),
    INDEX idx_timestamp (timestamp)
);
```

**JPA Entity:**
```java
@Entity
@Table(name = "audit_log")
public class AuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String entityType;
    private Long entityId;
    
    @Enumerated(EnumType.STRING)
    private AuditAction action;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    @Column(columnDefinition = "jsonb")
    private String oldValues;
    
    @Column(columnDefinition = "jsonb")
    private String newValues;
    
    @CreationTimestamp
    private Instant timestamp;
    
    private String ipAddress;
}

public enum AuditAction {
    CREATE, UPDATE, DELETE
}
```

**AuditInterceptor:**
```java
@Aspect
@Component
public class AuditInterceptor {
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @AfterReturning("@annotation(auditable)")
    public void audit(JoinPoint joinPoint, Auditable auditable) {
        // Extract method parameters
        // Compare old vs new values
        // Save to audit_log
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Auditable {
    String action() default "UPDATE";
}
```

**Usage:**
```java
@Service
public class ArticleService {
    @Auditable(action = "CREATE")
    public ArticleDto createArticle(ArticleDto dto) {
        // Create article
        // Automatically logged by interceptor
    }
}
```

---

### Q41: How would you handle distributed transactions across services?

**Answer:**
For operations spanning auth-service and blog-service:

**Option 1: Saga Pattern (Distributed Transactions)**
```java
@Service
public class UserOnboardingSaga {
    private final AuthServiceClient authClient;
    private final BlogServiceClient blogClient;
    
    @Transactional
    public void createUserWithBlog(User user, Article firstArticle) {
        // Step 1: Create user in auth-service
        User created = authClient.createUser(user);
        
        try {
            // Step 2: Create article in blog-service
            firstArticle.setAuthorId(created.getId());
            blogClient.createArticle(firstArticle);
        } catch (Exception e) {
            // Compensating transaction: rollback user creation
            authClient.deleteUser(created.getId());
            throw e;
        }
    }
}
```

**Option 2: Event-Driven Architecture**
```java
// When user created in auth-service
@Service
public class AuthService {
    @Autowired
    private KafkaTemplate<String, UserCreatedEvent> kafkaTemplate;
    
    public User registerUser(RegisterRequest request) {
        User user = userRepository.save(new User(request));
        
        // Publish event
        kafkaTemplate.send("user-created", new UserCreatedEvent(user.getId(), user.getEmail()));
        
        return user;
    }
}

// Blog service listens
@Service
public class UserEventListener {
    @KafkaListener(topics = "user-created")
    public void handleUserCreated(UserCreatedEvent event) {
        // Initialize user workspace
        // Create welcome article
        // Send welcome email
    }
}
```

**Current System:**
- No cross-service transactions (each service independent)
- Each service manages its own data
- Coordination happens at API level (frontend orchestrates)
- This is intentional for loose coupling

---

### Q42: How would you optimize database queries for large datasets?

**Answer:**
Several optimization techniques:

**1. Query Optimization:**
```java
// Bad: N+1 problem (fetches user for each article)
List<Article> articles = articleRepository.findAll();
for (Article a : articles) {
    System.out.println(a.getAuthor().getEmail());
}

// Good: Fetch join
@Query("SELECT a FROM Article a JOIN FETCH a.author")
List<Article> findAllWithAuthor();

// Or lazy loading with eager fetch type
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(name = "author_id")
private User author;
```

**2. Pagination:**
```java
// Instead of loading all rows
List<Article> all = articleRepository.findAll(); // 100,000 rows!

// Use pagination
Page<Article> page = articleRepository.findAll(PageRequest.of(0, 20));
// Only fetches 20 rows
```

**3. Indexing:**
```sql
CREATE INDEX idx_articles_author_id ON articles(author_id);
CREATE INDEX idx_articles_created_at ON articles(created_at DESC);
CREATE INDEX idx_articles_publish_status ON articles(publish_status);
```

**4. Projection (DTOs):**
```java
// Instead of full entity
SELECT a FROM Article a  -- loads ALL columns + author

// Use projection
@Query("SELECT new com.example.blog.dto.ArticleSummaryDto(" +
       "a.id, a.title, a.tags, a.publishStatus) " +
       "FROM Article a")
List<ArticleSummaryDto> findAllSummaries();
// Loads only necessary columns
```

**5. Caching:**
```java
@Cacheable(value = "popular-articles", key = "'all'", cacheManager = "redisManager")
public List<ArticleDto> getPopularArticles() {
    // Cache entire result set
}
```

**6. Query Timeout:**
```properties
spring.jpa.properties.hibernate.generate_statistics=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
```

---

### Q43: How would you implement API rate limiting per user?

**Answer:**
Currently system has IP-based rate limiting. Add per-user limits:

**Redis-based Rate Limiter:**
```java
@Component
public class UserRateLimitFilter extends OncePerRequestFilter {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final int REQUEST_LIMIT = 100;  // 100 requests
    private static final long TIME_WINDOW = 60;     // per 60 seconds
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
            HttpServletResponse response, FilterChain filterChain) {
        
        String userEmail = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        
        if (userEmail != null) {
            String key = "ratelimit:user:" + userEmail;
            Long currentCount = redisTemplate.opsForValue().increment(key);
            
            if (currentCount == 1) {
                redisTemplate.expire(key, Duration.ofSeconds(TIME_WINDOW));
            }
            
            if (currentCount > REQUEST_LIMIT) {
                response.setStatus(429);
                response.getWriter().write("Rate limit exceeded");
                return;
            }
            
            response.addHeader("X-RateLimit-Limit", String.valueOf(REQUEST_LIMIT));
            response.addHeader("X-RateLimit-Remaining", String.valueOf(Math.max(0, REQUEST_LIMIT - currentCount)));
        }
        
        filterChain.doFilter(request, response);
    }
}
```

**Different Limits by User Role:**
```java
int limit = user.getRole() == Role.ADMIN ? 1000 : 100;
```

---

### Q44: How would you implement feature flags?

**Answer:**
Enable/disable features without redeploying:

**Configuration:**
```properties
# application.properties
feature.article-versioning=true
feature.article-sharing=false
feature.email-notifications=true
```

**FeatureFlags Service:**
```java
@Service
public class FeatureFlagService {
    @Value("${feature.article-versioning:false}")
    private boolean articleVersioningEnabled;
    
    @Value("${feature.article-sharing:false}")
    private boolean articleSharingEnabled;
    
    public boolean isEnabled(String feature) {
        return switch(feature) {
            case "article-versioning" -> articleVersioningEnabled;
            case "article-sharing" -> articleSharingEnabled;
            default -> false;
        };
    }
}

// Or use Redis for dynamic flags
@Service
public class DynamicFeatureFlagService {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean isEnabled(String feature) {
        String value = redisTemplate.opsForValue().get("feature:" + feature);
        return "true".equals(value);
    }
}
```

**Usage:**
```java
@Service
public class ArticleService {
    @Autowired
    private FeatureFlagService featureFlags;
    
    public ArticleDto updateArticle(Long id, ArticleDto dto) {
        Article article = articleRepository.findById(id).orElseThrow();
        article.setTitle(dto.getTitle());
        
        // Only save version if feature enabled
        if (featureFlags.isEnabled("article-versioning")) {
            saveVersion(article);
        }
        
        return articleMapper.toDto(articleRepository.save(article));
    }
}
```

---

### Q45: How would you implement activity logging for analytics?

**Answer:**
Track user activities for analytics and insights:

**Events to Track:**
- User login/logout
- Article created/updated/deleted
- Article viewed
- Search queries

**Event Entity:**
```java
@Entity
@Table(name = "activity_logs")
public class ActivityLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    private String eventType;  // login, article_create, etc.
    private String description;
    
    @CreationTimestamp
    private Instant timestamp;
    
    private String ipAddress;
    private String userAgent;
}
```

**Activity Logger:**
```java
@Service
public class ActivityLogger {
    @Autowired
    private ActivityLogRepository activityLogRepository;
    
    @Autowired
    private HttpServletRequest request;
    
    public void logActivity(User user, String eventType, String description) {
        ActivityLog log = new ActivityLog();
        log.setUser(user);
        log.setEventType(eventType);
        log.setDescription(description);
        log.setIpAddress(getClientIp(request));
        log.setUserAgent(request.getHeader("User-Agent"));
        activityLogRepository.save(log);
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0];
        }
        return request.getRemoteAddr();
    }
}
```

**Usage:**
```java
@Service
public class ArticleService {
    @Autowired
    private ActivityLogger activityLogger;
    
    public ArticleDto createArticle(ArticleDto dto) {
        Article article = new Article();
        article.setTitle(dto.getTitle());
        Article saved = articleRepository.save(article);
        
        activityLogger.logActivity(
            getCurrentUser(),
            "article_create",
            "Created article: " + article.getTitle()
        );
        
        return articleMapper.toDto(saved);
    }
}
```

**Analytics Queries:**
```sql
-- Most active users
SELECT user_id, COUNT(*) as activities
FROM activity_logs
WHERE timestamp > NOW() - INTERVAL '30 days'
GROUP BY user_id
ORDER BY activities DESC
LIMIT 10;

-- Activity by type
SELECT event_type, COUNT(*) as count
FROM activity_logs
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY event_type;
```

---

### Q46: How would you handle real-time notifications with WebSockets?

**Answer:**
Add real-time updates when articles are published:

**Dependencies:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

**WebSocket Configuration:**
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws/articles")
                .setAllowedOrigins("http://localhost:3000")
                .withSockJS();
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/app");
    }
}
```

**WebSocket Handler:**
```java
@Service
public class ArticleNotificationService {
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    public void notifyArticlePublished(Article article) {
        ArticleNotificationDto notification = new ArticleNotificationDto(
            "Article published: " + article.getTitle(),
            article.getId(),
            Instant.now()
        );
        
        // Send to all subscribers of /topic/articles
        messagingTemplate.convertAndSend("/topic/articles", notification);
    }
}
```

**Frontend Subscription:**
```typescript
import SockJS from 'sockjs-client';
import Stomp from 'stompjs';

const useArticleNotifications = () => {
    useEffect(() => {
        const socket = new SockJS('/ws/articles');
        const stompClient = Stomp.over(socket);
        
        stompClient.connect({}, (frame) => {
            console.log('Connected: ' + frame.server);
            
            // Subscribe to article notifications
            stompClient.subscribe('/topic/articles', (message) => {
                const notification = JSON.parse(message.body);
                console.log('New article: ' + notification.message);
                // Update UI
            });
        });
        
        return () => {
            if (stompClient.connected) {
                stompClient.disconnect();
            }
        };
    }, []);
};
```

---

### Q47: How would you implement role-based menu visibility in frontend?

**Answer:**
Show different UI based on user role:

**Frontend:**
```typescript
interface User {
    email: string;
    role: 'USER' | 'ADMIN';
}

const Navigation = () => {
    const { isAuthenticated } = useAuth();
    const [user, setUser] = useState<User | null>(null);
    
    useEffect(() => {
        api.get('/auth/me').then(response => {
            setUser(response.data);
        });
    }, []);
    
    return (
        <nav>
            <Link to="/articles">Articles</Link>
            
            {user?.role === 'ADMIN' && (
                <>
                    <Link to="/admin/users">Manage Users</Link>
                    <Link to="/admin/analytics">Analytics</Link>
                </>
            )}
            
            {isAuthenticated && (
                <button onClick={() => logout()}>Logout</button>
            )}
        </nav>
    );
};
```

**Backend Role Validation:**
```java
@RestController
public class AdminController {
    @GetMapping("/admin/users")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<UserDto>> getUsers() {
        // Only admins can access
    }
}
```

---

### Q48: How would you implement soft deletes (archive instead of delete)?

**Answer:**
Keep deleted records for compliance:

**Database Schema:**
```sql
ALTER TABLE articles ADD COLUMN deleted_at TIMESTAMP NULL;
ALTER TABLE articles ADD COLUMN deleted_by BIGINT REFERENCES users(id);
```

**JPA Entity:**
```java
@Entity
@Table(name = "articles")
@SQLDelete(sql = "UPDATE articles SET deleted_at = NOW(), " +
           "deleted_by = CURRENT_USER WHERE id = ?")
@Where(clause = "deleted_at IS NULL")
public class Article {
    @Id
    private Long id;
    
    private String title;
    private String content;
    
    @Column(name = "deleted_at")
    private Instant deletedAt;
    
    @ManyToOne
    @JoinColumn(name = "deleted_by")
    private User deletedBy;
}
```

**Service:**
```java
@Service
public class ArticleService {
    @Transactional
    @PreAuthorize("hasRole('ADMIN') or @articleSecurity.isOwner(authentication, #id)")
    public void deleteArticle(Long id) {
        Article article = articleRepository.findById(id).orElseThrow();
        article.setDeletedAt(Instant.now());
        article.setDeletedBy(getCurrentUser());
        articleRepository.save(article);
        // Actual row not deleted, just marked
    }
    
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public void permanentlyDeleteArticle(Long id) {
        // Use SQL to actually delete
        articleRepository.deleteById(id);
    }
    
    @Transactional
    @PreAuthorize("hasRole('ADMIN') or @articleSecurity.isOwner(authentication, #id)")
    public void restoreArticle(Long id) {
        // Query without @Where filter
        Article article = entityManager.createQuery(
            "SELECT a FROM Article a WHERE a.id = ? AND a.deletedAt IS NOT NULL",
            Article.class
        ).setParameter(1, id).getSingleResult();
        
        article.setDeletedAt(null);
        article.setDeletedBy(null);
        articleRepository.save(article);
    }
}
```

---

### Q49: How would you implement content moderation?

**Answer:**
Flag and review articles before publication:

**Moderation Status:**
```java
public enum ModerationStatus {
    DRAFT,           // Not yet submitted for moderation
    PENDING_REVIEW,  // Awaiting moderator review
    APPROVED,        // Approved, can be published
    REJECTED,        // Rejected, needs revision
}

@Entity
@Table(name = "articles")
public class Article {
    @Enumerated(EnumType.STRING)
    private ModerationStatus moderationStatus;
    
    @Column(name = "moderation_reason")
    private String moderationReason;
    
    @ManyToOne
    @JoinColumn(name = "reviewed_by")
    private User reviewedBy;
}
```

**Moderation Service:**
```java
@Service
public class ModerationService {
    @Autowired
    private ArticleRepository articleRepository;
    
    @Transactional
    @PreAuthorize("hasRole('USER')")
    public void submitForReview(Long articleId) {
        Article article = articleRepository.findById(articleId).orElseThrow();
        article.setModerationStatus(ModerationStatus.PENDING_REVIEW);
        articleRepository.save(article);
    }
    
    @Transactional
    @PreAuthorize("hasRole('MODERATOR')")
    public void approveArticle(Long articleId) {
        Article article = articleRepository.findById(articleId).orElseThrow();
        article.setModerationStatus(ModerationStatus.APPROVED);
        article.setReviewedBy(getCurrentUser());
        articleRepository.save(article);
    }
    
    @Transactional
    @PreAuthorize("hasRole('MODERATOR')")
    public void rejectArticle(Long articleId, String reason) {
        Article article = articleRepository.findById(articleId).orElseThrow();
        article.setModerationStatus(ModerationStatus.REJECTED);
        article.setModerationReason(reason);
        article.setReviewedBy(getCurrentUser());
        articleRepository.save(article);
        
        // Notify author
        emailService.sendRejectionNotice(article.getAuthor(), reason);
    }
}
```

---

### Q50: How would you implement a recommendation engine for articles?

**Answer:**
Suggest relevant articles to users:

**Database Schema:**
```sql
CREATE TABLE user_preferences (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    tag VARCHAR(50) NOT NULL,
    score FLOAT DEFAULT 1.0,  -- Relevance score
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(user_id, tag)
);

CREATE TABLE article_tags (
    article_id BIGINT,
    tag VARCHAR(50),
    PRIMARY KEY (article_id, tag),
    FOREIGN KEY (article_id) REFERENCES articles(id)
);
```

**Recommendation Service:**
```java
@Service
public class RecommendationService {
    @Autowired
    private ArticleRepository articleRepository;
    
    @Autowired
    private UserPreferenceRepository preferenceRepository;
    
    public List<ArticleDto> getRecommendations(User user, int limit) {
        // Get user's tag preferences
        List<UserPreference> preferences = preferenceRepository.findByUser(user);
        
        if (preferences.isEmpty()) {
            // Cold start: return trending articles
            return getTrendingArticles(limit);
        }
        
        // Get articles matching preferred tags, weighted by score
        Map<String, Float> tagWeights = preferences.stream()
            .collect(Collectors.toMap(
                UserPreference::getTag,
                UserPreference::getScore
            ));
        
        // Query articles with matching tags
        List<Article> articles = articleRepository.findByTagsIn(
            tagWeights.keySet()
        );
        
        // Score articles based on tag matches
        List<ScoredArticle> scored = articles.stream()
            .map(article -> new ScoredArticle(
                article,
                article.getTags().split(",")
                    .stream()
                    .mapToDouble(tag -> tagWeights.getOrDefault(tag.trim(), 0f))
                    .sum()
            ))
            .sorted(Comparator.comparing(ScoredArticle::getScore).reversed())
            .collect(Collectors.toList());
        
        return scored.stream()
            .limit(limit)
            .map(sa -> articleMapper.toDto(sa.getArticle()))
            .collect(Collectors.toList());
    }
    
    public void updateUserPreferences(User user, Article article) {
        // When user views/reads article, update preferences
        String[] tags = article.getTags().split(",");
        for (String tag : tags) {
            UserPreference pref = preferenceRepository.findByUserAndTag(user, tag)
                .orElse(new UserPreference(user, tag, 0f));
            pref.setScore(pref.getScore() + 1.0f);
            preferenceRepository.save(pref);
        }
    }
    
    private List<ArticleDto> getTrendingArticles(int limit) {
        // Return most viewed/liked articles
    }
}

class ScoredArticle {
    Article article;
    Float score;
}
```

**API Endpoint:**
```java
@GetMapping("/articles/recommendations")
@PreAuthorize("isAuthenticated()")
public ResponseEntity<List<ArticleDto>> getRecommendations(
    @RequestParam(defaultValue = "10") int limit) {
    return ResponseEntity.ok(
        recommendationService.getRecommendations(getCurrentUser(), limit)
    );
}
```

---

## Summary

This document covers:
- **Architecture** (Microservices, JWT, Caching)
- **Backend** (Spring Boot, Security, Services)
- **Frontend** (React, State Management, Forms)
- **Security** (Authentication, Authorization, CSRF, XSS)
- **Database** (Schema, Migrations, Concurrency)
- **DevOps** (Docker, Deployment, Environment Management)
- **Advanced Topics** (Search, Versioning, Email, Internationalization, Auditing, Real-time Updates, Recommendations)

These 50 questions cover fundamental concepts, real-world implementation patterns, and advanced features that would be expected in an interview for this system.
